# HTTPS

- HTTPS = HTTP + TLS

- Encryption: data is scrambled so outsiders can't read it.
- Integrity: ensures data isn't tampered with in transit. (e.g., man in the middle attack)
- Authentication: verifies the server (and sometimes the client) is who they claim to be.

## Workflow

1. **TCP Handshake**
   - Before TLS starts, the browser and server establish a TCP connection (the classic 3-way handshake).
     - Client → SYN
     - Server → SYN-ACK
     - Client → ACK
     - Now TCP is ready, and TLS can begin.

2. **ClientHello**
    - Browser → Server. The message contains the following:
      - Supported TLS versions (e.g. TLS 1.2, TLS 1.3) - for this case consider 1.3
      - Supported cipher suites (algorithms for key exchange, encryption, hashing)
      - Random number (used later in key generation)
      - Key share (part of Diffie-Hellman key exchange for ephemeral keys)
      - Optional: Extensions (like Server Name Indication, to tell which domain if multiple run on the same IP)

3. **ServerHello**
    - Server → Browser. The message contains the following:
      - The chosen TLS version (e.g., 1.3)
      - The chosen cipher suite (must be one the client supports)
      - Another random number
      - Key share (server’s side of the Diffie-Hellman exchange)
    - `openssl s_client -connect www.google.com:443` to get this response
    - In TLS 1.3 the server certificate is sent in a latter step! (TLS 1.2 only) The server's digital certificate (X.509) (signed by a trusted Certificate Authority), containing: Public key, Domain name, Issuer (CA), Signature from the CA. The server proves its identity via this certificate.

4. **Certificate Verification**
   - The client (browser) checks:
     - Is the cert issued by a trusted CA (in root store)? (verified with a public key pre-installed in the OS)
     - Is the cert valid (date, revocation)?
     - Does the cert domain match the URL?
   - If not → Browser shows “Your connection is not private”.
   - `echo | openssl s_client -connect www.google.com:443 2>/dev/null | openssl x509 -noout -text` to parse the certificate

5. **Key Exchange**
    - Browser generates a session key (for symmetric encryption) → securely shares it with server (using RSA/ECDHE, etc.).
    - It's hard to share a key over the internet! That's why a Diffie Hellman Exchange algorithm is used

6. Secure Session
    - All further HTTP traffic is encrypted with that session key.

```txt
   Browser (Client)                              Server
        |                                          |
        |--- ClientHello ------------------------->|
        |                                          |
        |<----------------- ServerHello, Cert -----|
        |                                          |
        |--- Session Key (encrypted) ------------->|
        |                                          |
        |<---------------- Secure ACK -------------|
        |                                          |
   >>> All HTTP traffic now encrypted <<<
```

## Encryption

- In HTTPS, `symmetric encryption` is used for data transfer

- Why `RSA` (asymmetric) is not used in HTTPS
  - RSA encryption is slow
  - For bi-directional communication, RSA key pairs are required on both sides

## Cipher Suite

- Set of protocols to be used in the communication
  - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
  - `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256`
- `ECDHE`: Elliptic Curve Diffie Hellman Exchange
- `ECDSA`: Elliptic Curve Digital Signature Algorithm

## Deliverying key for encryption

### Without Diffie Hellman

- the TLS key is generated by the client
- The TLS key is encrypted with the server public key
- The TLS key encrypted is sent to the server

- Drawbacks!
  - The same rsa key pair of the server is used both for authentication and data encryption
  - RSA pair should be used only for authentication! Not for descryption

### With Diffie Hellman

- The public key of the server is NOT used for encryption
- The key for encryption is negotiate using diffie hellman algorithm

  - This algorithm generate keys over insecure public connection
  - Nevertherless only they know the keys generated!
  - Use one way function
    - **Modulus**: (g^a mod p)^b mod p = g^ab mod p // (g^b mod p)^a mod p = g^ba mod p
    - **Elliptic curve** (ECDHE): y^2 = x^3 + ax + b // m(nG) = n(mG)
